<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pendulum Lab üï∞Ô∏è</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #canvas {
            display: block;
            background: radial-gradient(circle at center, #f7f1e3, #e8dcc0);
            cursor: grab;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
            backdrop-filter: blur(10px);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #ffd700;
            font-size: 14px;
        }

        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin: 2px;
            transition: transform 0.2s;
        }

        button:hover {
            transform: scale(1.05);
        }

        button.active {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #333;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        input[type="range"] {
            width: 150px;
            margin: 5px;
        }

        .title {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(45deg, #ffd700, #ffed4e, #fff59d);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
        }

        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            backdrop-filter: blur(10px);
            font-size: 12px;
            color: #aaa;
        }

        .measurements {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            backdrop-filter: blur(10px);
            font-size: 14px;
            color: #ffd700;
        }

        .nav-home {
            position: absolute;
            top: 200px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 5px;
            border: 1px solid #333;
            color: #667eea;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <a href="physics-simulator.html" class="nav-home">‚Üê Back to Home</a>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <div class="title">üï∞Ô∏è Pendulum Lab</div>
        
        <div class="control-group">
            <label>Length: <span id="lengthValue">1.0</span> m</label>
            <input type="range" id="length" min="0.5" max="3.0" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>Mass: <span id="massValue">1.0</span> kg</label>
            <input type="range" id="mass" min="0.5" max="5.0" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>Gravity: <span id="gravityValue">9.8</span> m/s¬≤</label>
            <input type="range" id="gravity" min="1" max="20" step="0.5" value="9.8">
        </div>

        <div class="control-group">
            <label>Damping: <span id="dampingValue">0.01</span></label>
            <input type="range" id="damping" min="0" max="0.1" step="0.005" value="0.01">
        </div>

        <div class="control-group">
            <label>Controls:</label>
            <button id="startStop" class="active">Stop</button>
            <button id="reset">Reset</button>
            <button id="addPendulum">Add Pendulum</button>
        </div>

        <div class="control-group">
            <label>Display:</label>
            <button id="toggleTrails">Trails: ON</button>
            <button id="togglePhase">Phase Space</button>
        </div>
    </div>

    <div class="measurements">
        <div><strong>Current Measurements:</strong></div>
        <div>Period: <span id="period">--</span> s</div>
        <div>Frequency: <span id="frequency">--</span> Hz</div>
        <div>Angular Velocity: <span id="angularVel">--</span> rad/s</div>
        <div>Energy: <span id="energy">--</span> J</div>
        <div>Amplitude: <span id="amplitude">--</span>¬∞</div>
    </div>

    <div class="info">
        <strong>Pendulum Lab:</strong><br>
        ‚Ä¢ Drag the pendulum bob to set initial angle<br>
        ‚Ä¢ Adjust length, mass, gravity, and damping<br>
        ‚Ä¢ Watch the period change with length<br>
        ‚Ä¢ Add multiple pendulums for comparison
    </div>

    <script>
        class PendulumLab {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.pendulums = [];
                this.running = false;
                this.showTrails = true;
                this.showPhaseSpace = false;
                
                this.length = 1.0;
                this.mass = 1.0;
                this.gravity = 9.8;
                this.damping = 0.01;
                
                this.scale = 200; // pixels per meter
                this.time = 0;
                
                this.dragging = false;
                this.dragPendulum = null;
                
                this.setupCanvas();
                this.setupControls();
                this.setupEventListeners();
                this.addInitialPendulum();
                this.animate();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.centerX = this.canvas.width / 2;
                this.centerY = 100;
            }
            
            setupControls() {
                document.getElementById('length').oninput = (e) => {
                    this.length = parseFloat(e.target.value);
                    document.getElementById('lengthValue').textContent = this.length.toFixed(1);
                    this.updateSelectedPendulum();
                };
                
                document.getElementById('mass').oninput = (e) => {
                    this.mass = parseFloat(e.target.value);
                    document.getElementById('massValue').textContent = this.mass.toFixed(1);
                    this.updateSelectedPendulum();
                };
                
                document.getElementById('gravity').oninput = (e) => {
                    this.gravity = parseFloat(e.target.value);
                    document.getElementById('gravityValue').textContent = this.gravity.toFixed(1);
                };
                
                document.getElementById('damping').oninput = (e) => {
                    this.damping = parseFloat(e.target.value);
                    document.getElementById('dampingValue').textContent = this.damping.toFixed(3);
                };
                
                document.getElementById('startStop').onclick = () => this.toggleRunning();
                document.getElementById('reset').onclick = () => this.reset();
                document.getElementById('addPendulum').onclick = () => this.addPendulum();
                document.getElementById('toggleTrails').onclick = () => this.toggleTrails();
                document.getElementById('togglePhase').onclick = () => this.togglePhaseSpace();
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
            }
            
            addInitialPendulum() {
                this.addPendulum();
            }
            
            addPendulum() {
                const pendulum = {
                    id: Date.now(),
                    x: this.centerX,
                    y: this.centerY,
                    length: this.length,
                    mass: this.mass,
                    angle: Math.PI / 6, // 30 degrees
                    angularVelocity: 0,
                    trail: [],
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                    lastPeriodTime: 0,
                    periodTimes: [],
                    maxAngle: Math.PI / 6
                };
                
                this.pendulums.push(pendulum);
            }
            
            updateSelectedPendulum() {
                if (this.pendulums.length > 0) {
                    const pendulum = this.pendulums[this.pendulums.length - 1]; // Update last added
                    pendulum.length = this.length;
                    pendulum.mass = this.mass;
                }
            }
            
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Find pendulum bob to drag
                for (let pendulum of this.pendulums) {
                    const bobX = pendulum.x + Math.sin(pendulum.angle) * pendulum.length * this.scale;
                    const bobY = pendulum.y + Math.cos(pendulum.angle) * pendulum.length * this.scale;
                    
                    const distance = Math.sqrt((mouseX - bobX) ** 2 + (mouseY - bobY) ** 2);
                    if (distance < 20) {
                        this.dragging = true;
                        this.dragPendulum = pendulum;
                        this.running = false;
                        document.getElementById('startStop').textContent = 'Start';
                        document.getElementById('startStop').classList.remove('active');
                        break;
                    }
                }
            }
            
            handleMouseMove(e) {
                if (!this.dragging || !this.dragPendulum) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Calculate angle from pivot to mouse
                const dx = mouseX - this.dragPendulum.x;
                const dy = mouseY - this.dragPendulum.y;
                const angle = Math.atan2(dx, dy);
                
                this.dragPendulum.angle = angle;
                this.dragPendulum.angularVelocity = 0;
                this.dragPendulum.maxAngle = Math.abs(angle);
            }
            
            handleMouseUp(e) {
                this.dragging = false;
                this.dragPendulum = null;
            }
            
            updatePendulums(dt) {
                if (!this.running) return;
                
                this.pendulums.forEach(pendulum => {
                    // Simple pendulum equation: d¬≤Œ∏/dt¬≤ = -(g/L)sin(Œ∏) - damping*dŒ∏/dt
                    const angularAcceleration = -(this.gravity / pendulum.length) * Math.sin(pendulum.angle) 
                                               - this.damping * pendulum.angularVelocity;
                    
                    pendulum.angularVelocity += angularAcceleration * dt;
                    pendulum.angle += pendulum.angularVelocity * dt;
                    
                    // Update trail
                    if (this.showTrails) {
                        const bobX = pendulum.x + Math.sin(pendulum.angle) * pendulum.length * this.scale;
                        const bobY = pendulum.y + Math.cos(pendulum.angle) * pendulum.length * this.scale;
                        
                        pendulum.trail.push({ x: bobX, y: bobY });
                        if (pendulum.trail.length > 200) {
                            pendulum.trail.shift();
                        }
                    }
                    
                    // Calculate period (time between zero crossings)
                    if (pendulum.angle > 0 && pendulum.angularVelocity < 0) {
                        const currentTime = this.time;
                        if (pendulum.lastPeriodTime > 0) {
                            const period = 2 * (currentTime - pendulum.lastPeriodTime);
                            pendulum.periodTimes.push(period);
                            if (pendulum.periodTimes.length > 10) {
                                pendulum.periodTimes.shift();
                            }
                        }
                        pendulum.lastPeriodTime = currentTime;
                    }
                });
                
                this.time += dt;
            }
            
            calculateMeasurements() {
                if (this.pendulums.length === 0) return;
                
                const pendulum = this.pendulums[0]; // Use first pendulum for measurements
                
                // Average period
                let avgPeriod = 0;
                if (pendulum.periodTimes.length > 0) {
                    avgPeriod = pendulum.periodTimes.reduce((a, b) => a + b, 0) / pendulum.periodTimes.length;
                }
                
                const frequency = avgPeriod > 0 ? 1 / avgPeriod : 0;
                const angularVel = Math.abs(pendulum.angularVelocity);
                
                // Energy calculation
                const kineticEnergy = 0.5 * pendulum.mass * (pendulum.angularVelocity * pendulum.length) ** 2;
                const potentialEnergy = pendulum.mass * this.gravity * pendulum.length * (1 - Math.cos(pendulum.angle));
                const totalEnergy = kineticEnergy + potentialEnergy;
                
                const amplitude = pendulum.maxAngle * 180 / Math.PI;
                
                document.getElementById('period').textContent = avgPeriod > 0 ? avgPeriod.toFixed(3) : '--';
                document.getElementById('frequency').textContent = frequency > 0 ? frequency.toFixed(3) : '--';
                document.getElementById('angularVel').textContent = angularVel.toFixed(3);
                document.getElementById('energy').textContent = totalEnergy.toFixed(3);
                document.getElementById('amplitude').textContent = amplitude.toFixed(1);
            }
            
            render() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw background gradient
                const gradient = this.ctx.createRadialGradient(
                    this.canvas.width/2, this.canvas.height/2, 0,
                    this.canvas.width/2, this.canvas.height/2, Math.max(this.canvas.width, this.canvas.height)
                );
                gradient.addColorStop(0, '#f7f1e3');
                gradient.addColorStop(1, '#e8dcc0');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw phase space if enabled
                if (this.showPhaseSpace && this.pendulums.length > 0) {
                    this.drawPhaseSpace();
                }
                
                // Draw pendulums
                this.pendulums.forEach(pendulum => {
                    this.drawPendulum(pendulum);
                });
                
                // Draw reference lines
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.centerY);
                this.ctx.lineTo(this.canvas.width, this.centerY);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
            
            drawPendulum(pendulum) {
                const bobX = pendulum.x + Math.sin(pendulum.angle) * pendulum.length * this.scale;
                const bobY = pendulum.y + Math.cos(pendulum.angle) * pendulum.length * this.scale;
                
                // Draw trail
                if (this.showTrails && pendulum.trail.length > 1) {
                    this.ctx.strokeStyle = pendulum.color;
                    this.ctx.lineWidth = 2;
                    this.ctx.globalAlpha = 0.5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(pendulum.trail[0].x, pendulum.trail[0].y);
                    for (let i = 1; i < pendulum.trail.length; i++) {
                        this.ctx.lineTo(pendulum.trail[i].x, pendulum.trail[i].y);
                    }
                    this.ctx.stroke();
                    this.ctx.globalAlpha = 1;
                }
                
                // Draw string
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(pendulum.x, pendulum.y);
                this.ctx.lineTo(bobX, bobY);
                this.ctx.stroke();
                
                // Draw pivot
                this.ctx.fillStyle = '#333';
                this.ctx.beginPath();
                this.ctx.arc(pendulum.x, pendulum.y, 5, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw bob
                const bobRadius = Math.max(8, Math.sqrt(pendulum.mass) * 10);
                this.ctx.save();
                this.ctx.shadowColor = pendulum.color;
                this.ctx.shadowBlur = 15;
                
                this.ctx.fillStyle = pendulum.color;
                this.ctx.beginPath();
                this.ctx.arc(bobX, bobY, bobRadius, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Highlight if dragging
                if (this.dragPendulum === pendulum) {
                    this.ctx.strokeStyle = '#ffff00';
                    this.ctx.lineWidth = 3;
                    this.ctx.stroke();
                }
                
                this.ctx.restore();
            }
            
            drawPhaseSpace() {
                const phaseX = this.canvas.width - 200;
                const phaseY = this.canvas.height - 200;
                const phaseSize = 150;
                
                // Phase space background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(phaseX, phaseY, phaseSize, phaseSize);
                
                // Phase space axes
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(phaseX, phaseY + phaseSize/2);
                this.ctx.lineTo(phaseX + phaseSize, phaseY + phaseSize/2);
                this.ctx.moveTo(phaseX + phaseSize/2, phaseY);
                this.ctx.lineTo(phaseX + phaseSize/2, phaseY + phaseSize);
                this.ctx.stroke();
                
                // Plot pendulum in phase space
                this.pendulums.forEach(pendulum => {
                    const x = phaseX + phaseSize/2 + (pendulum.angle / Math.PI) * phaseSize/2;
                    const y = phaseY + phaseSize/2 - (pendulum.angularVelocity / 10) * phaseSize/2;
                    
                    this.ctx.fillStyle = pendulum.color;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    this.ctx.fill();
                });
                
                // Labels
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Phase Space', phaseX + phaseSize/2, phaseY - 10);
                this.ctx.fillText('Œ∏', phaseX + phaseSize + 10, phaseY + phaseSize/2);
                this.ctx.save();
                this.ctx.translate(phaseX - 10, phaseY + phaseSize/2);
                this.ctx.rotate(-Math.PI/2);
                this.ctx.fillText('œâ', 0, 0);
                this.ctx.restore();
            }
            
            toggleRunning() {
                this.running = !this.running;
                const button = document.getElementById('startStop');
                button.textContent = this.running ? 'Stop' : 'Start';
                if (this.running) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            }
            
            toggleTrails() {
                this.showTrails = !this.showTrails;
                document.getElementById('toggleTrails').textContent = `Trails: ${this.showTrails ? 'ON' : 'OFF'}`;
                
                if (!this.showTrails) {
                    this.pendulums.forEach(p => p.trail = []);
                }
            }
            
            togglePhaseSpace() {
                this.showPhaseSpace = !this.showPhaseSpace;
                document.getElementById('togglePhase').textContent = this.showPhaseSpace ? 'Hide Phase' : 'Phase Space';
            }
            
            reset() {
                this.pendulums.forEach(pendulum => {
                    pendulum.angle = Math.PI / 6;
                    pendulum.angularVelocity = 0;
                    pendulum.trail = [];
                    pendulum.periodTimes = [];
                    pendulum.lastPeriodTime = 0;
                    pendulum.maxAngle = Math.PI / 6;
                });
                this.time = 0;
                this.running = false;
                document.getElementById('startStop').textContent = 'Start';
                document.getElementById('startStop').classList.remove('active');
            }
            
            animate() {
                const dt = 0.016; // ~60fps
                
                this.updatePendulums(dt);
                this.calculateMeasurements();
                this.render();
                
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize the lab
        const lab = new PendulumLab();
    </script>
</body>
</html>